import re
from langchain.utilities import SQLDatabase
import os
from dotenv import load_dotenv

load_dotenv()

user = os.getenv("USER")
pwd = os.getenv("PSWD")
database_url = os.getenv("DATABASE_URL")

# --------------------------------------------------------------------

def get_db():
    return SQLDatabase.from_uri(
        f"postgresql://{user}:{pwd}@{database_url}/postgres",
        sample_rows_in_table_info=0,
    )

db = get_db()

# --------------------------------------------------------------------

# These are passed in RunnablePassthrough


def get_schema(_):
    return db.get_table_info()


def run_query(query):
    return db.run(query)


# --------------------------------------------------------------------

# Gemma specific custom parser, as LLM output is different.


def custom_str_parser(output):
    """Parses the SQL query from Gemma-7b's output, handling variations."""
    sql_match = re.search(r"(`sql\n(.*?)\n`)", output, flags=re.DOTALL)
    if sql_match:
        return sql_match.group(2).strip()  # Extract SQL query from code block
    else:
        # Handle cases where the SQL query is not within code block
        alt_match = re.search(r"SELECT (.*?) FROM", output, flags=re.IGNORECASE)
        if alt_match:
            return alt_match.group(1).strip()  # Extract first part of SELECT statement
        else:
            return f"Error {alt_match}"


# --------------------------------------------------------------------


# Handle when no SQL query is generated by initial chain.
def handle_error_query(data):
    if "error" in data["query"].lower():
        return "This query seems to contain an error. Please rephrase it."
    else:
        return db.run(data["query"])


# --------------------------------------------------------------------
